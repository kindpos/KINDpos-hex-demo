<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KINDpos - Hexagonal Navigation Demo</title>
    <style>
        /* Import Google Fonts as placeholders */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #333333;
            font-family: 'Share Tech Mono', monospace;
        }

        /* Main navigation container */
        .nav-container {
            width: 100%;
            height: 100%;
            background-color: #333333;
            border: 3px solid #c6ffbb;
            position: relative;
            overflow: hidden;
            padding: 20px;
        }

        /* SVG container for hexagons */
        .hex-svg {
            width: 100%;
            height: 100%;
        }

        /* Hexagon styling */
        .hexagon {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        /* Hexagon polygon (the shape itself) */
        .hex-shape {
            fill: transparent;
            stroke-width: 5;
            transition: all 0.3s ease;
        }

        /* Color variants for hexagons */
        .hex-shape.orange {
            stroke: #ff931e;
        }

        .hex-shape.blue {
            stroke: #3fa9f5;
        }

        .hex-shape.green {
            stroke: #7ac943;
        }

        /* Hover state - semi-transparent fill */
        .hexagon:hover .hex-shape {
            fill-opacity: 0.2;
        }

        .hexagon:hover .hex-shape.orange {
            fill: #ff931e;
        }

        .hexagon:hover .hex-shape.blue {
            fill: #3fa9f5;
        }

        .hexagon:hover .hex-shape.green {
            fill: #7ac943;
        }

        /* Selected state - solid fill and thicker stroke */
        .hexagon.selected .hex-shape {
            stroke-width: 10;
            fill-opacity: 1;
        }

        .hexagon.selected .hex-shape.orange {
            fill: #ff931e;
        }

        .hexagon.selected .hex-shape.blue {
            fill: #3fa9f5;
        }

        .hexagon.selected .hex-shape.green {
            fill: #7ac943;
        }

        /* Hexagon text */
        .hex-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 18px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }

        /* Smaller text for item hexagons */
        .hexagon[data-type="item"] .hex-text {
            font-size: 14px;
        }

        /* Text color variants to match hex colors */
        .hex-text.orange-text {
            fill: #ff931e;
        }

        .hex-text.blue-text {
            fill: #3fa9f5;
        }

        .hex-text.green-text {
            fill: #7ac943;
        }

        /* When hex is selected/filled, text becomes dark */
        .hexagon.selected .hex-text {
            fill: #333333;
        }
    </style>
</head>
<body>
    <div class="nav-container">
        <svg class="hex-svg" viewBox="0 0 600 600" preserveAspectRatio="xMidYMid meet">
            <!-- Hexagons will be generated by JavaScript -->
        </svg>
    </div>
    <script>
        // KINDpos Hexagonal Navigation Demo
        console.log('KINDpos Hex Navigation Demo Loaded');

        // Hexagon math utilities
        const HexMath = {
            // Generate the 6 points of a hexagon given center (cx, cy) and radius
            generateHexPoints(cx, cy, radius) {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2; // Start from top, go clockwise
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    points.push(`${x},${y}`);
                }
                return points.join(' ');
            },

            // Check if a hexagon would be inside the viewBox
            isInsideViewBox(x, y, radius, viewBox) {
                const margin = 20; // Keep some margin from edges
                return (
                    x - radius > margin &&
                    x + radius < viewBox.width - margin &&
                    y - radius > margin &&
                    y + radius < viewBox.height - margin
                );
            },

            // Calculate positions for hexagons surrounding a center hex
            // Returns array of {x, y} positions for surrounding hexes
            getSurroundingPositions(centerX, centerY, centerRadius, surroundRadius) {
                const positions = [];
                // Distance from center to surrounding hex centers
                const distance = (centerRadius + surroundRadius) * 1.05; // 1.05 adds small gap
                
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i; // 60 degree intervals
                    const x = centerX + distance * Math.cos(angle);
                    const y = centerY + distance * Math.sin(angle);
                    positions.push({ x, y });
                }
                return positions;
            },

            // Get additional positions in a second ring for more items
            getExpandedPositions(centerX, centerY, radius, count) {
                const positions = [];
                
                // First, get the standard surrounding positions (6 positions)
                const firstRing = this.getSurroundingPositions(centerX, centerY, radius, radius * 0.75);
                positions.push(...firstRing);
                
                // Then add honeycomb-style positions that fill gaps
                // These are offset positions between the first ring hexes
                const distance = radius * 1.75 * 1.05;
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + (Math.PI / 6); // Offset by 30 degrees
                    const x = centerX + distance * 1.5 * Math.cos(angle);
                    const y = centerY + distance * 1.5 * Math.sin(angle);
                    positions.push({ x, y });
                }
                
                return positions.slice(0, Math.max(count, 12));
            },

            // Calculate positions for a second ring of hexagons (items around subcat+cat)
            getSecondRingPositions(centerX, centerY, centerRadius, ringRadius) {
                const positions = [];
                const distance = (centerRadius + ringRadius) * 2.1; // Roughly 2 hex-widths out
                
                // 12 positions in second ring (2 per face of center hex)
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI / 6) * i; // 30 degree intervals for denser packing
                    const x = centerX + distance * Math.cos(angle);
                    const y = centerY + distance * Math.sin(angle);
                    positions.push({ x, y });
                }
                return positions;
            }
        };

        // Hexagon rendering
        function createHexagonElement(x, y, radius, label, colorClass, type = 'cat') {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('hexagon');
            g.setAttribute('data-type', type);
            g.setAttribute('data-id', label.toLowerCase().replace(/\s+/g, '-'));
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.classList.add('hex-shape', colorClass);
            polygon.setAttribute('points', HexMath.generateHexPoints(x, y, radius));
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.classList.add('hex-text', `${colorClass}-text`);
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.textContent = label;
            
            g.appendChild(polygon);
            g.appendChild(text);
            
            return g;
        }

        // Menu data structure
        const menuData = {
            food: {
                label: 'FOOD',
                color: 'orange',
                subcats: {
                    appetizers: {
                        label: 'Appetizers',
                        items: ['Wings', 'Nachos', 'Salad']
                    },
                    entrees: {
                        label: 'Entrees',
                        items: ['Burger', 'Steak', 'Pasta', 'Tacos']
                    }
                }
            },
            drinks: {
                label: 'DRINKS',
                color: 'blue',
                subcats: {
                    cocktails: {
                        label: 'Cocktails',
                        items: ['Margarita', 'Mojito', 'Martini']
                    },
                    beer: {
                        label: 'Beer',
                        items: ['IPA', 'Lager', 'Stout']
                    }
                }
            },
            desserts: {
                label: 'DESSERTS',
                color: 'green',
                subcats: {
                    cakes: {
                        label: 'Cakes',
                        items: ['Chocolate', 'Vanilla', 'Carrot']
                    }
                }
            }
        };

        // Navigation state
        let currentState = {
            level: 'cat', // 'cat', 'subcat', 'item'
            selectedCat: null,
            selectedSubcat: null,
            catPosition: null // Store the position when CAT is selected
        };

        // Demo: Create interactive navigation
        document.addEventListener('DOMContentLoaded', async () => {
            // Wait for fonts to load before starting
            try {
                await document.fonts.ready;
            } catch (e) {
                console.log('Font loading check skipped');
            }
            
            const svg = document.querySelector('.hex-svg');
            
            const hexRadius = 80;
            const gapMultiplier = 1.08;
            const horizontalSpacing = hexRadius * Math.sqrt(3) * gapMultiplier;
            const verticalSpacing = hexRadius * 1.5 * gapMultiplier;
            
            function clearSVG() {
                svg.innerHTML = '';
            }
            
            function showCatLevel() {
                clearSVG();
                currentState.level = 'cat';
                currentState.selectedCat = null;
                currentState.selectedSubcat = null;
                
                // Show all three CATs
                const foodHex = createHexagonElement(150, 120, hexRadius, 'FOOD', 'orange', 'cat');
                foodHex.addEventListener('click', () => selectCat('food', 150, 120));
                svg.appendChild(foodHex);
                
                const drinksHex = createHexagonElement(150 + horizontalSpacing, 120, hexRadius, 'DRINKS', 'blue', 'cat');
                drinksHex.addEventListener('click', () => selectCat('drinks', 150 + horizontalSpacing, 120));
                svg.appendChild(drinksHex);
                
                const dessertsHex = createHexagonElement(150 + horizontalSpacing / 2, 120 + verticalSpacing, hexRadius, 'DESSERTS', 'green', 'cat');
                dessertsHex.addEventListener('click', () => selectCat('desserts', 150 + horizontalSpacing / 2, 120 + verticalSpacing));
                svg.appendChild(dessertsHex);
            }
            
            function selectCat(catId, x, y) {
                clearSVG();
                currentState.level = 'subcat';
                currentState.selectedCat = catId;
                currentState.catPosition = { x, y };
                
                const cat = menuData[catId];
                
                // Show selected CAT (locked in place)
                const catHex = createHexagonElement(x, y, hexRadius, cat.label, cat.color, 'cat');
                catHex.classList.add('selected');
                catHex.addEventListener('click', () => showCatLevel()); // Click to go back
                svg.appendChild(catHex);
                
                // Show subcats around it
                const subcatKeys = Object.keys(cat.subcats);
                const positions = HexMath.getSurroundingPositions(x, y, hexRadius, hexRadius);
                
                subcatKeys.forEach((subcatKey, i) => {
                    const subcat = cat.subcats[subcatKey];
                    const pos = positions[i];
                    const subcatHex = createHexagonElement(pos.x, pos.y, hexRadius, subcat.label, cat.color, 'subcat');
                    subcatHex.addEventListener('click', () => selectSubcat(subcatKey, pos.x, pos.y));
                    svg.appendChild(subcatHex);
                });
            }
            
            function selectSubcat(subcatId, x, y) {
                clearSVG();
                currentState.level = 'item';
                currentState.selectedSubcat = subcatId;
                
                const cat = menuData[currentState.selectedCat];
                const subcat = cat.subcats[subcatId];
                
                const viewBox = { width: 600, height: 600 };
                
                // Show CAT (locked)
                const catHex = createHexagonElement(currentState.catPosition.x, currentState.catPosition.y, hexRadius, cat.label, cat.color, 'cat');
                catHex.classList.add('selected');
                catHex.addEventListener('click', () => showCatLevel());
                svg.appendChild(catHex);
                
                // Show selected subcat (locked)
                const subcatHex = createHexagonElement(x, y, hexRadius, subcat.label, cat.color, 'subcat');
                subcatHex.classList.add('selected');
                subcatHex.addEventListener('click', () => selectCat(currentState.selectedCat, currentState.catPosition.x, currentState.catPosition.y));
                svg.appendChild(subcatHex);
                
                const itemRadius = 60;
                
                // Track which hexagons exist and where
                const hexagons = [
                    { x: currentState.catPosition.x, y: currentState.catPosition.y, radius: hexRadius, label: 'CAT' },
                    { x: x, y: y, radius: hexRadius, label: 'Appetizers' }
                ];
                
                // Function to determine which faces of a hexagon have neighbors
                function getOccupiedFaces(targetHex) {
                    const occupiedFaces = [false, false, false, false, false, false]; // 6 faces
                    const threshold = (hexRadius + itemRadius) * 1.2; // Distance threshold for neighbor detection
                    
                    for (let otherHex of hexagons) {
                        if (otherHex === targetHex) continue; // Skip self
                        
                        // Calculate distance
                        const dx = otherHex.x - targetHex.x;
                        const dy = otherHex.y - targetHex.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Only consider it a neighbor if close enough
                        if (distance > threshold) continue;
                        
                        // Calculate angle from target to other hex
                        let angle = Math.atan2(dy, dx);
                        
                        // Normalize to 0-2π range
                        if (angle < 0) angle += Math.PI * 2;
                        
                        // Hexagon faces are at 60° intervals
                        // Face 0: 90° (top), Face 1: 30° (top-right), Face 2: 330° (bottom-right)
                        // Face 3: 270° (bottom), Face 4: 210° (bottom-left), Face 5: 150° (top-left)
                        
                        // Adjust angle so 0° is at the top
                        let adjustedAngle = angle + Math.PI / 2;
                        if (adjustedAngle >= Math.PI * 2) adjustedAngle -= Math.PI * 2;
                        
                        // Determine which 60° sector this angle falls into
                        const face = Math.round(adjustedAngle / (Math.PI / 3)) % 6;
                        
                        occupiedFaces[face] = true;
                        console.log(`${targetHex.label} has neighbor ${otherHex.label} on face ${face} (angle: ${(angle * 180 / Math.PI).toFixed(1)}°)`);
                    }
                    
                    return occupiedFaces;
                }
                
                // Function to get positions for empty faces
                function getPositionsForEmptyFaces(hex, occupiedFaces, itemRadius) {
                    const positions = [];
                    const itemDistance = (hex.radius + itemRadius) * 1.05;
                    
                    // For each empty face, create a position
                    for (let face = 0; face < 6; face++) {
                        if (!occupiedFaces[face]) {
                            // Calculate angle for this face, with 30° offset for flat-to-flat alignment
                            const angle = -Math.PI / 2 + (Math.PI / 3) * face + (Math.PI / 6);
                            
                            positions.push({
                                x: hex.x + itemDistance * Math.cos(angle),
                                y: hex.y + itemDistance * Math.sin(angle),
                                face: face
                            });
                        }
                    }
                    
                    return positions;
                }
                
                // Get empty faces for both CAT and Subcat
                let catOccupiedFaces = getOccupiedFaces(hexagons[0]);
                let subcatOccupiedFaces = getOccupiedFaces(hexagons[1]);
                
                console.log(`Total valid positions needed: ${subcat.items.length}`);
                
                // Simple demo: Place first 3 items in a ring around parent
                console.log(`\n=== Placing first 3 items around Appetizers ===`);
                
                const itemsToShow = subcat.items.slice(0, 3); // Just Wings, Nachos, Salad
                
                // Get positions around Appetizers
                const parentOccupiedFaces = getOccupiedFaces(hexagons[1]);
                const parentPositions = getPositionsForEmptyFaces(hexagons[1], parentOccupiedFaces, itemRadius);
                
                console.log(`Parent provides ${parentPositions.length} positions`);
                
                // Filter for in-bounds positions
                const validPositions = parentPositions.filter(pos => 
                    HexMath.isInsideViewBox(pos.x, pos.y, itemRadius, viewBox)
                );
                
                console.log(`${validPositions.length} valid positions available`);
                
                // Place first 3 items
                itemsToShow.forEach((item, i) => {
                    if (i < validPositions.length) {
                        const pos = validPositions[i];
                        console.log(`✓ Placing ${item} at (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
                        
                        const itemHex = createHexagonElement(pos.x, pos.y, itemRadius, item, cat.color, 'item');
                        svg.appendChild(itemHex);
                        hexagons.push({ x: pos.x, y: pos.y, radius: itemRadius, label: item });
                    }
                });
            }
            
            // Start at CAT level
            showCatLevel();
        });
    </script>
</body>
</html>
